#!/usr/bin/python
# -*- coding: UTF-8 -*-

"""
 Created by qijianpeng on 2018/10/13.
 Email: jianpengqi@126.com
"""
import os
import pandas as pd
import numpy as np
import math
import sys
from texttable import Texttable

class DataUtil(object):
  """
  提供数据相关的工具方法
  """
  @staticmethod
  def loadData(dataDirStr=os.path.dirname(__file__) + "/../../../data", dataUser=None):
      """
      使用Pandas包加载数据，参考：http://www.gregreda.com/2013/10/26/using-pandas-on-the-movielens-dataset/
      Args:
        `dataDir`: 数据集文件夹位置。绝对路径。
      Returns:
        `users, ratings, movies, full, Rm`:
           `users`: 用户信息的DataFrame, 索引: ['user_id', 'age', 'sex', 'occupation', 'zip_code']
           `ratings`: 用户与电影评分DataFrame, 索引: ['user_id', 'movie_id', 'rating', 'unix_timestamp']
           `movies`: 电影信息DataFrame，['movie_id', 'title', 'release_date', 'video_release_date', 'imdb_url']
           `full`: 所有电影join操作后的DataFrame, `(users join in ratings on user_id) join in  movies on movie_id`.
           `Rm`: 评分矩阵（下标都是从0开始），为了便于计算，由DataFrame转换而来。每一行代表一个用户对所有item的评分记录，每一列代表一个item被所有用户评分的记录。

      :param dataDir: datasets directory. Default is `<project_working_root>/data`
      :return `users, ratings, movies, full, Rm`: `users, ratings, movies` are DataFrames generated by `pandas`,
                                              `Rm` is rating matrix.(one row per user).
      """
      dataDir = os.path.abspath(dataDirStr)
      # pass in column names for each CSV
      u_cols = ['user_id', 'age', 'sex', 'occupation', 'zip_code']
      users = pd.read_csv(dataDir + '/ml-100k/u.user', sep='|', names=u_cols)

      # Loading user ratings.
      r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']
      _dataUser = dataDir + '/ml-100k/ua.base'
      if(dataUser != None):
        _dataUser = dataUser
      ratings = pd.read_csv(_dataUser, sep='\t', names=r_cols)

      # the movies file contains columns indicating the movie's genres
      # let's only load the first five columns of the file with usecols
      m_cols = ['movie_id', 'title', 'release_date', 'video_release_date', 'imdb_url']
      movies = pd.read_csv(dataDir + '/ml-100k/u.item', sep='|', names=m_cols, usecols=range(5))

      movie_ratings = pd.merge(movies, ratings)
      full = pd.merge(movie_ratings, users)
      # We only need numeric matrix, pivot full data into pure rating matrix.(one row per user)
      # Converts data into rating matrix like bellow:
      #    m1 m2 m3 .... mN
      # u1  2  1  0  ...  2
      # u2  3  0  2  ...  4
      # u3  4  3  0  ...  5
      # ..     ...
      # uM  4  3  0  ...  5
      Rm = full.pivot(index='user_id', columns='movie_id', values='rating').fillna(0).values
      return users, ratings, movies, full, Rm

  @staticmethod
  def loadUserTestingData(dataDirStr=os.path.dirname(__file__) + "/../../../data", dataFile="/ml-100k/ua.test"):
    dataPath = os.path.abspath(dataDirStr) + dataFile
    r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']
    ratings = pd.read_csv(dataPath, sep='\t', names=r_cols)
    # Converts to dict. {user_i: {item_j:ratings}}
    res = {}
    for index, row in ratings.iterrows():
      user_id = row['user_id']
      movie_id = row['movie_id']
      rating = row['rating']
      if res.has_key(user_id):
        pass
      else:
        res[user_id] = {}
      res[user_id][movie_id] = rating
    return res
# from ustb.cf.utils.cfutils import MatrixUtil, DataUtil
# ratings = DataUtil.loadUserTestingData(dataDirStr='/Users/qijianpeng/Documents/git/cfs/data', dataFile='/ml-100k/ua.test')

class MatrixUtil(object):
  """
  提供矩阵运算的工具方法
  """
  @staticmethod
  def dot_and(V1, V2):
    """计算同时存在元素值的点乘积，可认为两个矩阵相同位置都存在数值的计数
    `0`表示不存在，非`0`表示存在
    Suppose:
    V1 = [1, 2, 3, 0, 2]
         [2, 3, 0, 1, 0]
    V2 = [0, 1]
         [0, 1]
         [1, 2]
         [2, 5]
         [3, 0]'

    `dot_and(V1, V2)` returns number of common positive elements matrix:
    V = [2, 1]
        [1, 3].
    :param V1: N*M matrix
    :param V2: M*K matrix
    :return: matrix computed by dot_and way.
    """
    _V1 = (V1 > 0).astype(np.int)
    _V2 = (V2 > 0).astype(np.int)
    return np.dot(_V1, _V2)
